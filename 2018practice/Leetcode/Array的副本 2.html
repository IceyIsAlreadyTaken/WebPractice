<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script id="905. 按奇偶排序数组">
    //从左边开始先判断奇偶，奇数添加到队尾并删除，偶数不操作
    //难点在于，当 a走到数组中点时，奇数已经全部放到队尾，中止循环的方法
    var sortArrayByParity = function(A) {
    var b = 0
    for(var a = 0;;a++) {
        if(A[a] % 2 == 1) {
            A.push(A[a])
            A.splice(a,1)
            a-=1
        }
        b++
        if(b==A.length){
            break
        }
    }
    return A
    };
    var A =[3,1,2,4]
    sortArrayByParity(A)
    console.log(A)
  </script>

  <script id="832. 翻转图像">
      var flipAndInvertImage = function(A) {
      for(var a = 0;a < A.length;a++) {
          A[a]=A[a].reverse()
      }
      for(var a = 0;a < A.length;a++) {
        for(var b = 0;b < A.length;b++){
            if(A[a][b]==1){
                A[a][b]=0
            }else{
                A[a][b]=1
            }
        }
      }
      return A
    };
  </script>

  <script id="922. 按奇偶排序数组 II">
    var sortArrayByParityII = function(A) {
      var even = new Array()
      var odd = new Array()
      var e=0
      var o=0
      for(var a = 0;a < A.length;a++){
          if(A[a]%2==0){
              even.push(A[a])
          }else{
              odd.push(A[a])
          }
      }
      for(var a = 0;a < A.length;a++){
          if(a%2==0){
              A[a]=even[e]
              e+=1
          }else{
              A[a]=odd[o]
              o+=1
          }
      }
      return A
    };
  </script>

  <script id="?867. 转置矩阵">
    var transpose = function(A) {
    var hang = A.length
    var lie = A[0].length
    var B = new Array(lie)
    var C = new Array(hang)
    for (var a = 0;a < lie;a++) {
        B[a] = C
    }
    for (var a = 0;a < hang;a++) {
        for (var b = 0;b < lie;b++) {
          B[b][a]=A[a][b]
            console.log(B[b][a])
            console.log(B)
        }
    }
    return B
    };
  </script>

  <script id="561. 数组拆分 I">//需要优化
    var arrayPairSum = function(nums) {
    var B = new Array()
    var sum = 0
    for (var i = nums.length;i > 1;i--) {
      for (var j = 0;j < i - 1;j++) {
        if(nums[j] > nums[j+1]) {
            nums[j]=nums[j]+nums[j+1]
            nums[j+1]=nums[j]-nums[j+1]
            nums[j]=nums[j]-nums[j+1]
        }
      }  
    }
    for(var a = 0;a < nums.length;a += 2) {
        sum += nums[a]
    }
    return sum
    };
  </script>

  <script id="1. 两数之和">
    var twoSum = function(nums, target) {
      var A = new Array()
      for(var a = 0;a < nums.length - 1;a++) {
          for(var b = a+1;b< nums.length ;b++) {
              if(nums[a] + nums[b] == target) {
                  A.push(a,b)
                  return A
              }
          }
      }
    };
  </script>

  <script id="11. 盛最多水的容器">//需要优化
    var maxArea = function(height) {
    let big = 0
    let vol
    for (var a = 0;a < height.length-1;a++) {
        for(var b = a+1;b < height.length;b++) {
            if(height[b] > height[a]) {
              vol = height[a] * (b - a)
                
            }
            else {
              vol = height[b] * (b - a)
            }
            if(vol > big) {
              big = vol
            }
        }
    }
    return big
    };
    //执行用时: 1124 ms, 在Container With Most Water的JavaScript提交中击败了16.00% 的用户
  </script>

  <script id="15. 三数之和"> //超时
    var threeSum = function(nums) {
      let m = new Array()
      let n = new Array()
      for (let a = 0;a < nums.length - 2;a++) {
          for (let b = a + 1;b < nums.length - 1;b++) {
              for (let c = b + 1;c < nums.length;c++) {
                  if (nums[a] + nums[b] + nums[c] == 0) {
                      n.push(nums[a],nums[b],nums[c])
                      m.push(n)
                      n = []
                  }
              }
          }
      }
      let sum
      let bum
      for (let a = 0;a < m.length-1;a++) {
          for (let b = a + 1;b < m.length;b++) {
              sum = m[a][0] * m[a][1] * m[a][2]
              bum = m[b][0] * m[b][1] * m[b][2]
            if (sum == bum) {
                if (m[a].sort().toString() == m[b].sort().toString()) { //判断相等
                    m.splice(b,1)
                    b -= 1
                }
                
            } 
          }
      }
      return m
    };
  </script>

  <script id="">
  
  </script>

  <script id="">
  
  </script>

  <script id="">
  
  </script>

<script id="">
  
  </script>
</head>
<body>
  
</body>
</html>